# CVE-2020-35511

> A global buffer overflow was discovered in pngcheck function in pngcheck-2.4.0(5 patches applied) via a crafted png file.

## Vulnerability Analysis

While official sources don't specify the exact location of the vulnerability, based on the [discoverer's blog](https://www.giantbranch.cn/vulfound/), it likely stems from the `print_buffer` function lacking proper size parameter validation. The hypothesis is that when `size < 1`, the loop wouldn't terminate, causing an global buffer over-read.

## Code Review

The `print_buffer` function is used in processing 7 different chunk types in version 2.4.0:

### iCCP Chunk

```c
print_buffer(&prbuf_state, buffer, name_len, 0);
```

`name_len` is derived from `check_keyword` and cannot be negative.

### iTXt Chunk

```c
print_buffer(&prbuf_state, buffer, keylen, 0);
print_buffer(&prbuf_state, buffer+keylen+3, taglen, 0);
```

Both `keylen` and `taglen` are derived from `keywordlen` and cannot be negative.

### pCAL Chunk

```c
print_buffer(&prbuf_state, buffer, name_len, 0);
```

`name_len` is derived from `check_keyword` and cannot be negative.

### sPLT Chunk

```c
print_buffer(&prbuf_state, buffer, name_len, 0);
```

`name_len` is derived from `check_keyword` and cannot be negative.

### tEXt / zTXt Chunks

```c
print_buffer(&prbuf_state, buffer, keylen, 0);
print_buffer(&prbuf_state, buffer + keylen + 1, toread - keylen - 1, 1);
```

- `keylen` is derived from `check_keyword` and cannot be negative
- `toread - keylen - 1` has a minimum value of 0

### SEEK Chunk

```c
print_buffer(&prbuf_state, buffer, sz, 1);
```

`sz` is checked with `if (sz > 0)` before the function call.

## Conclusion

While the `print_buffer` function's design might theoretically be vulnerable, the implementation appears safe in practice because:

1. All size parameters are validated before being passed to the function
1. When `size == 0`, the `while (size--)` loop terminates immediately
